# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/07_im2im_annotator.ipynb (unless otherwise specified).

__all__ = ['ImCanvas', 'Im2ImAnnotator']

# Cell

import json
import textwrap
import uuid
import os
import random
import re

from functools import partial
import itertools as it
from math import ceil
from pathlib import Path

from ipycanvas import Canvas, hold_canvas
from ipyevents import Event
from ipywidgets import (AppLayout, VBox, HBox, Button, GridBox, Layout, Checkbox, HTML, IntText, Valid, Output)
from traitlets import Dict, Int, Float, HasTraits, observe, dlink, link, List, Unicode

from .navi_widget import Navi
from .storage import setup_project_paths, get_image_list_from_folder, AnnotationStorage
from .capture_annotator import CaptureGrid
from .image_button import ImageButton
from .bbox_canvas import draw_img


# Cell

class ImCanvas(HBox, HasTraits):
    image_path = Unicode()
    _image_scale = Float()

    def __init__(self, width=150, height=150):

        self._canvas = Canvas(width=width, height=height)

        super().__init__([self._canvas])

    @observe('image_path')
    def _draw_image(self, change):
        self._image_scale = draw_img(self._canvas, self.image_path, clear=True)

    # Add value as a read-only property
    @property
    def image_scale(self):
        return self._image_scale

    def _clear_image(self):
        self._canvas.clear()

    # needed to support voila
    # https://ipycanvas.readthedocs.io/en/latest/advanced.html#ipycanvas-in-voila
    def observe_client_ready(self, cb=None):
        self._canvas.on_client_ready(cb)

# Internal Cell

class Im2ImAnnotatorGUI(AppLayout):
    def __init__(self, im_width=300, im_height=300,
                       label_width=150, label_height=150,
                       n_rows=None, n_cols=None, label_autosize=False):

        if label_autosize:
            if im_width <100 or im_height < 100:
                label_width = 10
                label_height = 10
            elif im_width >1000 or im_height > 1000:
                label_width = 50
                label_height = 10
            else:
                label_width = min(im_width, im_height)/10
                label_height = label_width

        self.label_width = label_width
        self.label_height = label_height
        self.n_rows = n_rows
        self.n_cols = n_cols

        self._image = ImCanvas(width=im_width, height=im_height)

        self._navi = Navi()

        self._save_btn = Button(description="Save",
                                layout=Layout(width='auto'))


        self._controls_box = HBox([self._navi, self._save_btn],
                                 layout=Layout(display='flex', justify_content='center', flex_flow='wrap', align_items='center'))


        self._grid_box = CaptureGrid(grid_item=ImageButton, image_width=label_width, image_height=label_height,  n_rows=n_rows, n_cols=n_cols)


        self._grid_label = HTML(value="<b>LABEL</b>",)
        self._labels_box = VBox(children = [self._grid_label, self._grid_box],
                                layout=Layout(display='flex', justify_content='center', flex_wrap='wrap', align_items='center'))


        super().__init__(header=None,
                 left_sidebar=VBox([self._image, self._controls_box], layout=Layout(display='flex', justify_content='center', flex_wrap='wrap', align_items='center')),
                 center=self._labels_box,
                 right_sidebar=None,
                 footer=None,
                 pane_widths=(6, 4, 0),
                 pane_heights=(1, 1, 1))

    def on_client_ready(self, callback):
        self._image.observe_client_ready(callback)


# Internal Cell
def _label_state_to_storage_format(label_state):
    return [Path(k).name for k, v in label_state.items() if v['answer']]

# Internal Cell
def _storage_format_to_label_state(storage_format, label_names, label_dir):
    return {str(Path(label_dir)/label): {'answer': label in storage_format} for label in label_names}

# Internal Cell

from PIL import Image, ImageDraw, ImageFont


def text_on_img(text="Hello", lbl_w=None, lbl_h=None, font_size=14, filepath=None):
    font = ImageFont.truetype("lte50712.ttf", font_size)

    if lbl_w is None:
        lbl_w = 150
    if lbl_h is None:
        lbl_h = 150

    assert(text)

    text = text.upper()

    ascent, descent = font.getmetrics()

    text_width = font.getmask(text).getbbox()[2]
    text_height = font.getmask(text).getbbox()[3] + descent

    m_width, m_heigth = font.getsize("M")
    char_num_per_line = lbl_w // m_width

    image = Image.new(mode = "RGB", size = (lbl_w, lbl_h), color = "white")
    draw = ImageDraw.Draw(image)

    words = text.split()
    if len(words) <= 2 and all(font.getsize(w)[0] < lbl_w for w in words):
        t_wrapper = words
    else:
        t_wrapper = textwrap.wrap(text, char_num_per_line)


    offset = (lbl_h - (m_heigth * len(t_wrapper))) // 2

    for line in t_wrapper:
        line_w, line_h = font.getsize(line)
        draw.text(((lbl_w - line_w) // 2, offset), line, font=font, fill=(0,0,0))
        offset += line_h

    if filepath:
        image.save(filepath)

    return image




text_on_img(text="new labe")

# Internal Cell

#exporti

def grid_imgs(images, lbl_w=None, lbl_h=None, filepath=None,maxcols=2,maxrows=2):
    assert(images)

    if lbl_w is None:
        lbl_w = 150

    if lbl_h is None:
        lbl_h = 150

    grid = Image.new(mode="RGB", size=(lbl_w, lbl_h))
    cols, rows = (maxcols, maxrows) if len(images) >= maxcols*maxrows else (1, 1)

    w, h = lbl_w // cols, lbl_h // rows
    subset = images[:cols*rows]

    # We only use the first images of the subset
    for i, imgpath in enumerate(subset):
        # Using NEAREST as its the fastest and the images will be small
        original = Image.open(imgpath)
        ratio = original.width/original.height
        neww, newh = int(min(w,h)*ratio), int(min(w,h))
        img = original.resize((neww, newh), Image.NEAREST)
        x = i%cols*w + (w-neww)//2
        y = i//rows*h + (h-newh)//2
        grid.paste(img, (x, y))

    if filepath:
        grid.save(filepath)

    return grid

# Internal Cell

try:
    from collections.abc import Iterable
except ImportError:
    from collections import Iterable

def flatten(lis):
    for item in lis:
            if isinstance(item, Iterable) and not isinstance(item, str):
                for x in flatten(item):
                    yield x
            else:
                yield item

# Internal Cell

def reconstruct_class_images(label_dir, annotation_file, lbl_w=None, lbl_h=None):
    with open(annotation_file) as json_file:
        data = json.load(json_file)
        unique_classes = set(flatten(data.values())) # ipyannotator format

    for cl_name in unique_classes:
        if cl_name is None:
            cl_name = "None"

        cl_im_name = f'{cl_name}.jpg' if not re.findall("([-\w]+\.(?:jpg|png|jpeg))", cl_name, re.IGNORECASE) else cl_name

        # Searching for a bunch of sample images
        # We get a list with up to four images to avoid iterating through all the data
        sample_images = list(it.islice((im_path for im_path,classes in data.items()
                                        if classes and
                                           cl_name in flatten(classes) and
                                           Path(im_path).is_file()), 4))

        if sample_images:
            grid_imgs(sample_images, filepath = label_dir/cl_im_name,lbl_w=lbl_w, lbl_h=lbl_h,maxcols=2,maxrows=2)
        else:
            text_on_img(text = os.path.splitext(cl_name)[0], filepath = label_dir/cl_im_name, lbl_w=lbl_w, lbl_h=lbl_h)

# Internal Cell

class Im2ImAnnotatorLogic(HasTraits):
    debug_output = Output(layout={'border': '1px solid black'})
    index = Int(0) # state index
    image_path = Unicode() # current image path
    current_im_num = Int()
    disp_number = Int() # number of labels on screen
    label_state = Dict()
    question_value = Unicode()
    autogenerate_idx = Int()


    def __init__(self, project_path, file_name=None, question=None,
                 image_dir='pics', step_down=False,
                 label_dir=None, results_dir=None, lbl_w=None, lbl_h=None, n_cols=None, n_rows=None):

        self.project_path = Path(project_path)
        self.step_down = step_down
        self.lbl_w = lbl_w
        self.lbl_h = lbl_h
        self.image_dir, self.annotation_file_path = setup_project_paths(self.project_path,
                                                                        file_name=file_name,
                                                                        image_dir=image_dir,
                                                                        results_dir=results_dir)

        # artificialy generate labels if no class images given
        if label_dir is None:
            self.label_dir = Path(self.project_path, 'class_autogenerated_' + ''.join(random.sample(str(uuid.uuid4()), 5)))
            self.autogenerate_idx = 1
            self.label_dir.mkdir(parents=True, exist_ok=True)

            question = 'Autogenerated classes'

            if self.annotation_file_path.exists():
                reconstruct_class_images(self.label_dir, self.annotation_file_path, lbl_w=lbl_w, lbl_h=lbl_h)
            else:
                text_on_img(text = 'None', filepath = self.label_dir /'None.jpg', lbl_w=lbl_w, lbl_h=lbl_h)
        else:
            self.label_dir = Path(self.project_path, label_dir)
            self.autogenerate_idx = 0


        # select images and labels only given annotatin file
        if self.annotation_file_path.is_file():
            with self.annotation_file_path.open() as json_file:
                data = json.load(json_file)
                im_names = data.keys()
                unique_labels = set(flatten(data.values()))
            self.image_paths = sorted(im for im in get_image_list_from_folder(self.image_dir) if str(im) in im_names)
            self.labels_files = sorted(im for im in get_image_list_from_folder(self.label_dir, strip_path=True) if str(im) in unique_labels)
        else:
            self.image_paths = sorted(get_image_list_from_folder(self.image_dir))
            self.labels_files = sorted(get_image_list_from_folder(self.label_dir, strip_path=True))

        if not self.image_paths:
            raise Exception ("!! No Images to dipslay !!")
        if not self.labels_files:
            print("!! No labels to display !!")

        self.current_im_num = len(self.image_paths)
        labels_num = len(self.labels_files)

        if n_cols is None:
            if n_rows is None:  # automatic arrange
                self.label_cols = 3
                self.label_rows = ceil(labels_num / self.label_cols)
            else:  # calc cols to show all labels
                self.label_rows = n_rows
                self.label_cols = ceil(labels_num / self.label_rows)

        else:
            if n_rows is None:  # calc rows to show all labels
                self.label_cols = n_cols
                self.label_rows = ceil(labels_num / self.label_cols)
            else:  # user defined
                self.label_cols = n_cols
                self.label_rows = n_rows

        if (self.label_cols * self.label_rows < labels_num):
            print("!! Not all labels shown. Check n_cols, n_rows args !!")

        self.annotations = AnnotationStorage(self.image_paths, dir_in_label=step_down)

        if self.annotation_file_path.exists():
            self.annotations.load(self.annotation_file_path)
        else:
            self.annotations.save(self.annotation_file_path)

        if question:
            self.question_value = f'<center><p style="font-size:20px;">{question}</p></center>'


    def _update_im(self):
        self.image_path = str(self.image_paths[self.index])


    def _update_state(self, change=None): # from annotations
        if not self.image_path:
            return

        if self.image_path in self.annotations:
            current_annotation = self.annotations[self.image_path]
            self.label_state = _storage_format_to_label_state(storage_format=current_annotation or [],
                                                              label_names=self.labels_files,
                                                              label_dir=self.label_dir)


    def _update_annotations(self, index): # from screen
        if self.image_path:
            self.annotations[self.image_path] = _label_state_to_storage_format(self.label_state)

    def _save_annotations(self, *args, **kwargs): # to disk
        index = kwargs.pop('old_index', self.index)
        self._update_annotations(index)
        self.annotations.save(self.annotation_file_path)

        if self.autogenerate_idx:
            reconstruct_class_images(self.label_dir, self.annotation_file_path, lbl_w=self.lbl_w, lbl_h=self.lbl_h)
            self.autogenerate_idx += 1


    @observe('index')
    def _idx_changed(self, change):
        ''' On index change save old state
            and update current state for visualisation
        '''
        self._save_annotations(old_index = change['old'])
        # update new screen
        self._update_im()
        self._update_state()


    @debug_output.capture(clear_output=False)
    def _handle_grid_click(self, event, name=None):
        label_changed = Path(self.label_dir,  name)

        if label_changed.is_dir():
            # button without image - invalid
            return

        label_changed = str(label_changed)
        current_label_state = self.label_state.copy()

        # inverse state
        current_label_state[label_changed] = {'answer': not self.label_state[label_changed].get('answer', False)}

        # change traitlets.Dict entirely to have change events issued
        self.label_state = current_label_state


    def _handle_client_ready(self):
        self._update_im()
        self._update_state()

# Cell

class Im2ImAnnotator(Im2ImAnnotatorGUI):

    def __init__(self, project_path, file_name=None, image_dir=None, step_down=False, label_dir=None, results_dir=None,
                 im_width=100, im_height=100, label_width=150, label_height=150,
                 n_rows=None, n_cols=None, label_autosize=False, question=None):

        self._model = Im2ImAnnotatorLogic(project_path=project_path, file_name=file_name, question=question,
                                           image_dir=image_dir, step_down=step_down,
                                           label_dir=label_dir, results_dir=results_dir,
                                           lbl_w=label_width, lbl_h=label_height,
                                           n_rows=n_rows, n_cols=n_cols)


        super().__init__(im_width, im_height,
                         label_width, label_height,
                         n_rows = self._model.label_rows, n_cols = self._model.label_cols,
                         label_autosize = label_autosize)

        self._save_btn.on_click(self._model._save_annotations)

        self._grid_box.on_click(self._model._handle_grid_click)

        # set correct slider max value based on image number
        dlink((self._model, 'current_im_num'), (self._navi.model, 'max_im_number'))

        # link current image index from controls to annotator model
        link((self._navi.model, 'index'), (self._model, 'index'))

        # link annotation question
        link((self._model, 'question_value'), (self._grid_label, 'value'))

        #link image vizualizer
        dlink((self._model, 'image_path'), (self._image, 'image_path'))

        # draw current image and bbox only when client is ready
        self.on_client_ready(self._model._handle_client_ready)

        # link state of model and grid box visualizer
        link((self._model, 'label_state'), (self._grid_box, 'current_state'))
        link((self._model, 'autogenerate_idx'), (self._grid_box, 'autogenerate_idx'))


    def to_dict(self, only_annotated=True):
        return self._model.annotations.to_dict(only_annotated)